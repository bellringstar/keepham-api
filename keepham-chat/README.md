# Chat Server

## 웹소켓 연결을 통해 실시간 양방향 채팅 서버

API 서버의 경우 stateless 하지만 WebSocket을 사용하는 채팅의 경우 Session 관리가 필요하다.
따라서 성격이 다른 두 서버를 별도의 서버로 분리해서 유지보수성과 확장성을 높인다.

## 사용 기술
1. websocket
<br> 서브 프로토콜로 stomp를 사용해 메시지 브로커와의 상호작용을 단순화한다.
2. kafka
<br> 메시지큐 역할, 클러스터 구성을 통해 안정성과 확장성을 높인다.
3. redis
<br> api서버에서 인증된 토큰, websocket 세션 관리 db
4. mongoDB
<br> 채팅 기록 정구 저장과 복잡한 쿼리 필요시 사용을 위한 보조 db
<br> 추후 속도를 위해 key:value store로 주 db를 사용하고 mongoDB를 보조로 변경 예정

## 설계 초안
1:1 채팅의 경우 A,B 사용자가 있을 때 A사용자가 메시지를 B 유저 토픽에 publish하고 B유저와 웹소켓이 연결된 서버는 B토픽의 이벤트를 읽어 메시지를 보여주는 형태.
<br>이런 방식으로 하면 현재 B 유저가 웹소켓 연결이 아니더라도 이벤트를 통해 알림전송이 가능하다.
<br>
하지만 위 방식으로 하면 사용자별로 토픽을 만들어 관리하게 됨으로 토픽 관리의 복잡성이 증가한다. 차라리 채팅방 별로 토픽을 만들어 해당 채팅방에 입장시 그 토픽을 구독하고 메시지를 pub/sub하는 방식을 사용한다.
별도의 db를 통해 채팅방id, 해당 채팅방에 있는 유저를 관리하고 redis에 websocket session을 userId:session 형태로 관리해 메시지를 broadcast 하면서 websocket이 끊어져 있다면 해당 유저에는 FCM등을 통해 메시지 내용을 알림처리한다.
채팅 내용의 경우 유저가 채팅방에 입장을 위해 get요청을 할 때 메시지 내용을 db에서 읽어와 프론트엔드에서 표시해주는 형태로 처리한다.

예상 문제
- 토픽 관리
  채팅방이 증가함에 따라 토픽 수가 증가해 kafka 부하 문제는 여전하다.
1. 채팅방 ID를 해싱하여 특정 범위의 채팅방을 동일한 토픽에 배정해 최적화
   이 경우에는 같은 토픽을 구독하는 서로 다른 채팅방간의 메시지 혼선이 발생할 수 있다. 따라서 메시지 라우팅과 필터링이 필요하다.
  (1)프로듀서는 메시지 키로 채팅방 ID를 사용하여 메시지를 특정 토픽에 전송한다.
  (2)브로커는 메시지를 해당 파티션에 저장하고
  (3)컨슈머는 특정 토픽을 구족하고 메시지 키를 기준으로 자신이 속한 채팅방의 메시지만 필터링하여 처리한다.
2. 채팅방 종료시 해당 토픽 삭제

    채팅방 생성 시 새로운 토픽을 생성하고 채팅방 종료 시 해당 토픽을 삭제하는 방식이다. 
    이 경우에는 채팅방을 완전히 종료한다는 동작이 필요하며 채팅 내역이나 기록은 별도로 DB에 저장하고 종료된 채팅방에 입장하면 기존 메시지만 읽을 수 있는 상태가 된다.
    
하지만 너무 빈번한 토픽 생성 및 삭제는 kafka에 부가를 줄 수 있다.
최종적으로는 topic의 수를 제한하여 관리의 효율성을 높이는 방식을 사용한다. 
추후 토픽이 증가하게 되는 경우도 고려해 일관된 해싱이 필요하다.
    
1. 토픽을 미리 생성해 두고 채팅방 ID를 통해 특정 토픽에 배정을 한다.
2. 메시지 전송 시 메시지 키로 채팅방 ID를 설정해 동일 파티션으로 전송한다.
3. 컨슈머에서 필터링을 통해 각 채팅방의 메시지를 구분하여 처리한다.

- Redis 단일 장애 지점
  클러스터를 통해 가용성을 높인다.
- 메시지 순서 문제
  기본적으로 같은 파티션내에서는 메시지 순서를 보장하지만 단일 파티션은 확장성이 제한된다. 파티션은 토픽 내부를 나누는 부분으로 kafka의 주된 기능 중 하나다. 메시지를 여러 파티션으로 분산하여 병렬처리를 가능하게 하는 것이다.

메시지 키를 사용하여 동일한 채팅방의 메시지가 동일한 파티션에 할당되도록 처리한다.

참고로 파티션 수를 변경하면 기존 키와 파티션 간의 매핑이 달라질 수 있으니 주의가 필요하다.
- 네트워크 문제로 카프카에 메시지가 전달되지 않을 때, 메시지 유실 문제
  재시도 메커니즘을 통해 일정 횟수 재시도하고 그래도 실패시 log를 남긴다.
  ACK 설정을 통해 데이터 손실을 방지한다.
